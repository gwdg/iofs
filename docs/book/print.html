<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOFS documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction: What is IOFS?</a></li><li class="chapter-item expanded "><a href="setup/index.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/Installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="setup/HowToUse.html"><strong aria-hidden="true">2.2.</strong> How to Use</a></li><li class="chapter-item expanded "><a href="setup/BlackheapIntegration.html"><strong aria-hidden="true">2.3.</strong> Classify I/O with blackheap</a></li><li class="chapter-item expanded "><a href="setup/LocalGrafana.html"><strong aria-hidden="true">2.4.</strong> Local Grafana Setup with Docker</a></li></ol></li><li class="chapter-item expanded "><a href="Internal.html"><strong aria-hidden="true">3.</strong> How does it work?</a></li><li class="chapter-item expanded "><a href="extending/index.html"><strong aria-hidden="true">4.</strong> How to extend it</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extending/Metric.html"><strong aria-hidden="true">4.1.</strong> Add new metric</a></li><li class="chapter-item expanded "><a href="extending/Target.html"><strong aria-hidden="true">4.2.</strong> Add new streaming target</a></li></ol></li><li class="chapter-item expanded "><a href="Ressources.html"><strong aria-hidden="true">5.</strong> More ressources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">IOFS documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-what-is-iofs"><a class="header" href="#introduction-what-is-iofs">Introduction: What is IOFS?</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>It is very hard to analyze I/O requests and their performance as there are many parameters that determine request time, like</p>
<ul>
<li>Page alignment</li>
<li>VFS scheduling</li>
<li>Process scheduling and priority</li>
<li>Network congestion</li>
<li>Running programs</li>
<li>File system configuration</li>
</ul>
<p>and many more. Normal analysis tools often need sophisticated knowledge, elevated access and/or custom code adjustments.</p>
<p>For example, here is an overview of Linux highly complex I/O architecture:</p>
<p><a href="https://www.thomas-krenn.com/de/wiki/Linux_Storage_Stack_Diagramm"><img src="./assets/imgs/Linux-storage-stack-diagram_v4.0.png" alt="Overview of Linux Storage Stack" /></a></p>
<p>This results in most programmers, especially interdisciplinary researchers, not being able to sufficiently optimize their
I/O accesses. We try to solve this problem with a pure blackbox approach.</p>
<p>Our goals with our solution are the following:</p>
<ul>
<li>Give all HPC users a tool to monitor and rudimentary analyze their I/O</li>
<li>Require no code changes, no specific compiler, no specific linking</li>
<li>Easy to set up, no propriatary software or specfic knowledge required</li>
<li>Completely run in user space, no administration required</li>
<li>Integrate in common tooling for further analysis</li>
<li>Require no assumptions about the underlying server topology</li>
</ul>
<h2 id="our-approach"><a class="header" href="#our-approach">Our Approach</a></h2>
<p>As mentioned above, we developed <code>iofs</code> as a blackbox approach to report and, together with <a href="https://github.com/lquenti/blackheap"><code>blackheap</code></a>, classify all I/O requests without requiring any further information about the I/O hardware or software configuration.</p>
<h3 id="fuse"><a class="header" href="#fuse">FUSE</a></h3>
<p>We use the Linux userspace filesystem framework <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a> (Filesystem in Userspace) in order to intercept all I/O requests. FUSE works as follows:</p>
<p><a href="https://commons.wikimedia.org/wiki/File:FUSE_structure.svg"><img src="./assets/FUSE_structure.png" alt="Diagram how FUSE uses the VFS to support userspace filesystems" /></a></p>
<p>FUSE consists of two parts: The FUSE kernel module and the <code>libfuse</code> library to build file systems. We use FUSE to insert our monitoring logic.</p>
<h3 id="grafana--elasticsearch--influxdb"><a class="header" href="#grafana--elasticsearch--influxdb">Grafana / Elasticsearch / InfluxDB</a></h3>
<p>In order to allow for easier aggregated analysis of multiple clusters, we support data streaming.</p>
<p>Our inhouse data monitoring setup is set up as follows:</p>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<p>Although we use <a href="https://grafana.com/">Grafana</a> as our monitoring platform, <code>iofs</code> is platform agnostic, as it directly inserts the data into the underlying database.</p>
<h3 id="database"><a class="header" href="#database">Database</a></h3>
<p>We use the <a href="https://www.influxdata.com/">InfluxDB</a> TSDB (Time Series DataBase) as our data source for Grafana. <code>iofs</code> currently only supports the <a href="https://docs.influxdata.com/influxdb/v1.8/query_language/">InfluxQL</a> API, not the <a href="https://docs.influxdata.com/influxdb/v1.8/flux/">Flux</a> Syntax. Furthermore, <code>iofs</code> is only tested for InfluxDB 1.x.</p>
<p>We also have some streaming logic to support <a href="https://www.elastic.co/de/elasticsearch/">Elasticsearch</a> as a TSDB, although this is not tested nor actively maintained.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p>In order to track and monitor the I/O requests, the user is required to &quot;proxy&quot; all requests through our pseudo-filesystem. Once this is done, the high level workflow works as follows:</p>
<ul>
<li>User does a request on our pseudo filesystem</li>
<li>The request goes to the Linux VFS</li>
<li>The Linux VFS sees that this is a FUSE filesystem and lets the FUSE kernel module manage the request</li>
<li>The FUSE kernel module calls the appropriate <code>iofs</code> method for the requested operation.</li>
<li><code>iofs</code> extracts all request informations.
<ul>
<li>Then it maps the path to the real path</li>
<li>Does the underlying file system operation</li>
<li>Tracks how long the request takes</li>
<li>Aggregates all measured data into some global data structure</li>
<li>returns the result of the underlying operation</li>
</ul>
</li>
<li>The result gets passed to the FUSE kernel module, then gets passed to the VFS module, then gets passed to the caller.</li>
</ul>
<p>Every time interval, all aggregated metrics get streamed to any of the two TSDB supported. Note that this is non-blocking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>This short guide will show you how to <a href="setup/./Installation.html">install</a> <code>iofs</code> and use it</p>
<ul>
<li>locally in <a href="setup/./HowToUse.html">standalone mode</a> or</li>
<li><a href="setup/./LocalGrafana.html">with a Grafana/InfluxDB docker compose setup</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>The following dependencies are required:</p>
<ul>
<li><code>libcurl</code></li>
<li><code>fuse3</code></li>
<li><code>libfuse3-dev</code></li>
</ul>
<h2 id="build-process"><a class="header" href="#build-process">Build Process</a></h2>
<p>The build process is pretty straight forward</p>
<pre><code>mkdir build &amp;&amp; cd build
cmake ..
make
</code></pre>
<p>The binary can now be found at <code>./build/src/iofs</code>. In order to automatically install it, use</p>
<pre><code>make install
</code></pre>
<h3 id="further-options"><a class="header" href="#further-options">Further options</a></h3>
<p>You can set the install path with</p>
<pre><code>cmake --install-prefix=/opt/iofs/
</code></pre>
<p>To set the default path for the iofs config file, use</p>
<pre><code>cmake --DCONFIG_PATH=/opt/iofs/etc/iofs.conf ..
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-in-standalone-mode"><a class="header" href="#how-to-use-in-standalone-mode">How to Use (In standalone mode)</a></h1>
<p><a href="setup/./Installation.html">Once compiled</a>, <code>iofs</code> can be executed via</p>
<pre><code>iofs &lt;absolute_path_target&gt; &lt;absolute_path_source&gt;
</code></pre>
<p>Example: If you have your real data on <code>/data/my-data</code>, and want to measue it by accessing <code>/opt/iofs-data</code>, you'd use</p>
<pre><code>iofs /opt/iofs-data /data/my-data
</code></pre>
<h2 id="further-configuration"><a class="header" href="#further-configuration">Further Configuration</a></h2>
<p>All possible configuration settings can be seen via <code>iofs --help</code> or in the <code>example.conf</code> contained in this repository.</p>
<p>Everything except the mount points can be both configured via CLI parameters or config file. Note that the CLI parameters have a higher precedence.</p>
<p>There are 2 ways to use a configuration file:</p>
<ol>
<li>Define the configuration file path <a href="setup/./Installation.html">at compile time</a>.</li>
<li>Set the <code>IOFS_CONFIG_PATH</code> environment variable to the proper path, i.e.</li>
</ol>
<pre><code>IOFS_CONFIG_PATH=/home/user/example.conf iofs /opt/iofs-data /data/my-data
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classify-io-with-blackheap"><a class="header" href="#classify-io-with-blackheap">Classify I/O with blackheap</a></h1>
<p><a href="https://github.com/lquenti/blackheap">blackheap</a> can be used together with iofs to automatically classify incoming I/O requests based on their predicted characteristics.</p>
<h1 id="see-the-blackheap-documentation-for-more-information-on-how-to-use-it-with-iofs"><a class="header" href="#see-the-blackheap-documentation-for-more-information-on-how-to-use-it-with-iofs"><a href="https://lquenti.github.io/blackheap/book/StreamedClassifications.html">See the blackheap documentation for more information on how to use it with iofs.</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-grafana-setup-with-docker"><a class="header" href="#local-grafana-setup-with-docker">Local Grafana Setup with Docker</a></h1>
<h2 id="how-to-start"><a class="header" href="#how-to-start">How to start</a></h2>
<ul>
<li>Fill out the <code>.env</code> file</li>
<li>Start the <code>docker-compose</code></li>
<li>Unfortunately, <code>influx:1.x</code> doesn't initialize a database by default, even though it is defined in via the <code>.env</code> file. Thus we have to define our own database. See below.</li>
<li>Next, we have to define <code>influxdb</code> as the data source in grafana. See below.</li>
<li>If not done previously, we have to enable <code>user_allow_other</code> in the <code>/etc/fuse.conf</code></li>
<li>Lastly, we have to compile <code>iofs</code> (see roots <code>README.md</code>) and run it via</li>
</ul>
<pre><code>./iofs &lt;PATH_TO_WHERE_YOU_WRITE&gt; &lt;PATH_ON_WHAT_YOU_MAP&gt; --in-server=http://localhost:8086 --in-db=mydb
</code></pre>
<p>If you changed <code>INFLUX_DB</code> in <code>.env</code>, change <code>--in-db</code> accordingly.</p>
<p>Now you can create your first dashboard!</p>
<h2 id="create-initial-database-manually"><a class="header" href="#create-initial-database-manually">Create initial database manually</a></h2>
<ol>
<li>Start the docker-container (check with <code>docker container ls</code> afterwards).</li>
<li>Get a shell into the influxdb container. By default, the container is named <code>influxc</code>:</li>
</ol>
<pre><code>docker exec -it influxc bash
</code></pre>
<ol start="3">
<li>Now manually connect to the influxdb-cli. Use credentials according to the <code>.env</code> file.</li>
</ol>
<pre><code>influx -username influx -password influxdblongpassword123 -precision rfc3339
</code></pre>
<p>The precision defines the date format and <code>rfc3339</code> is used everywhere in the documentation
4. Once in the influxdb shell, create a database with</p>
<pre><code>CREATE DATABASE mydb;
</code></pre>
<p>The database name should match the name specified in the <code>.env</code>. Verify that it worked with</p>
<pre><code>SHOW DATABASES;
</code></pre>
<h2 id="add-the-already-initialized-influxdb-to-grafana"><a class="header" href="#add-the-already-initialized-influxdb-to-grafana">Add the (already initialized) influxdb to grafana</a></h2>
<ol>
<li>Start the docker-container (check with <code>docker container ls</code> afterwards).</li>
<li>Connect to grafana via <a href="http://localhost:3000/">http://localhost:3000/</a></li>
<li>Login with the credentials set in <code>.env</code> (<code>grafana</code>:<code>grafana</code> is default)</li>
<li>Go to <code>Configuration-&gt;Data Sources-&gt;Add Data Source-&gt;InfluxDB</code></li>
<li>Add the following configuration:</li>
</ol>
<p><strong>Query Language</strong>: Since we explicitly use <code>influxdb</code> version 1, we have to use InfluxQL.</p>
<p><strong>URL</strong>: Since we use docker compose (instead of the default network bridge) container name DNS is enabled. Thus we can use <a href="http://influxc:8086">http://influxc:8086</a>.</p>
<p><strong>InfluxDB Details</strong>: Use the <code>Database</code>, <code>User</code>, <code>Password</code> specified in the <code>.env</code></p>
<ol start="6">
<li>Afterwards test the configuration via <code>Save &amp; test</code>. If everything was configured successfully, it should show an alert with <code>Data source is working</code>. If you have the <code>docker-compose</code> logs open, you should see a request with a <code>Grafana/x.x.x</code> user agent as well.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflows"><a class="header" href="#workflows">Workflows</a></h1>
<h2 id="workflow-overview"><a class="header" href="#workflow-overview">Workflow Overview</a></h2>
<p>Here are some Graph representations of the workflows.</p>
<p>Firstly, the overall overview:</p>
<p><img src="../assets/graphs/general_flow.png" alt="Overview on how the functions call each other" /></p>
<p>Secondly, the reporting thread internals:</p>
<p><img src="../assets/graphs/reporthing_thread.png" alt="Overview on how the reporting thread works" /></p>
<h2 id="more-in-depth-overview"><a class="header" href="#more-in-depth-overview">More In-Depth Overview</a></h2>
<p>This section will be split into three parts:</p>
<ol>
<li>How does the program get initialized?</li>
<li>What happens if someone does a I/O request of any kind?</li>
<li>How is the data getting streamed into a TSDB?</li>
</ol>
<h3 id="how-does-the-program-get-initialized"><a class="header" href="#how-does-the-program-get-initialized">How does the program get initialized?</a></h3>
<p>At first, the main parses all arguments <a href="../setup/HowToUse.html">given</a> via cli arguments or configuration file, with the cli having higher precedence. Afterwards, it starts the <a href="https://libfuse.github.io/doxygen/fuse_8h.html"><code>fuse_main()</code></a>.</p>
<p>The <code>fuse_main()</code> is configured by a so-called <a href="https://libfuse.github.io/doxygen/structfuse__operations.html"><code>fuse_operations</code></a> struct. This struct has a bunch of function pointers, which represent the functions required to be implemented by an FUSE filesystem (some are optional). It additionally defines some other functions, like a <code>init</code> and <code>destroy</code> function for starting and stopping the file system.</p>
<p>So, in order to initialize the FUSE file system, the <code>fuse_main()</code> calls our <code>cache_init()</code>, which is just a wrapper around our real <code>monitor_init()</code>.</p>
<p>The <code>monitor_init()</code> initializes all aggregation data structures as well as <a href="https://libfuse.github.io/doxygen/structfuse__operations.html">cURL</a> for the REST data transfer. After that, it starts the <code>reporting_thread()</code> as a seperate <code>pthread</code>, which runs until the filesystem destroys itself via <code>cache_destroy()</code>.</p>
<h3 id="what-happens-if-someone-does-a-io-request-of-any-kind"><a class="header" href="#what-happens-if-someone-does-a-io-request-of-any-kind">What happens if someone does a I/O request of any kind?</a></h3>
<p>We already gave a higher level overview in the <a href="../Introduction.html">introduction</a>. But it works as follows:</p>
<p>At first, the user/caller calls any usual I/O function provided by the Linux kernel. This gets processed by the Linux VFS, which matches the proper kernel module for the file system. In our case, this is the FUSE kernel module.</p>
<p>The FUSE kernel module then calls the approprivate function given by our <a href="https://libfuse.github.io/doxygen/structfuse__operations.html"><code>fuse_operations</code> struct</a>. All our functions have the <code>cache_</code> prefix, thus calling the <code>X</code> function would end in <code>cache_X()</code>. This is only our personal convention.</p>
<p>After <code>cache_X</code> is called, we get the fake path prefix, which we have to map to where the file actually exists.</p>
<p>For example: We mounted <code>/data/real-data</code> to <code>/opt/fuse-playground</code>. Thus we get an I/O request for <code>/opt/fuse-playground/some-path/data.dat</code>, which we internally have to map to <code>/data/real-data/some-path/data.dat</code>.</p>
<p>After that is done, we can just call the same function <code>X</code> for our new path. This again gets passed through the VFS, but this time gets processed by the real file system kernel module.</p>
<p>When arriving the result, we track how long it took, and save the recorded data in our global structs. More on those in the next part. Lastly, we just return the same information we got back to the caller.</p>
<h3 id="how-is-the-data-getting-streamed-into-a-tsdb"><a class="header" href="#how-is-the-data-getting-streamed-into-a-tsdb">How is the data getting streamed into a TSDB?</a></h3>
<p>This is done by the aforementioned <code>reporting_thread()</code> method. This function runs in a endless loop until some state gets toggled by the <code>cache_destroy()</code> which is used to cleanup a filesystem before shutting down.</p>
<p>Every interval, which is chosen by the user, the function sends all aggregated data to the sources configured by the user.</p>
<p>This is pretty straightforward and the code is easily readable, as we just format and send our data in such a way to comply with Influx.</p>
<p>But one thing is still worth mentioning: How the data formatting and transfer is done non-blockingly without producing strongly inaccurate data.</p>
<p>This is done by having the global state two times. In essence, it works as follows:</p>
<ul>
<li>State 1 is ready to be sent</li>
<li>Tell the program to send all data to state 2</li>
<li>Process state 1, send it, wait until the interval is done</li>
<li>Switch back to state 1 and process state 2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-extend-it"><a class="header" href="#how-to-extend-it">How to extend it</a></h1>
<p>Any contributions are welcome. In this chapter, we explore how to extend</p>
<ul>
<li>The recorded metrics for both <a href="extending/../setup/HowToUse.html">standalone use</a> and <a href="extending/../setup/LocalGrafana.html">streaming</a>.</li>
<li>Add a new streaming target like a TSDB, relational database or other API.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-a-new-metric"><a class="header" href="#add-a-new-metric">Add a new metric</a></h1>
<p>TODO document after actually having it done yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-new-streaming-target"><a class="header" href="#add-new-streaming-target">Add new streaming target</a></h1>
<p>TODO document after adding the metrics yourself</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-ressources"><a class="header" href="#more-ressources">More ressources</a></h1>
<p>We first published a talk about iofs at the <a href="https://hps.vi4io.org/events/2022/iodc">HPC-IODC</a> workshop at the <a href="https://www.isc-hpc.com/">ISC 2022</a>.</p>
<p>Here are our slides:</p>
<ul>
<li><a href="https://hps.vi4io.org/_media/events/2022/iodc22-boden.pdf">FUSE-Based File System Monitoring and I/O Classification with IOFS</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
